# Algorithm first pseudocode draft. Developed by Marcos Ferrer Zalve (LTF)

The algorithm consists of several parts. Each one is described above its pseudocode section.

## Data proccesing from Database (job)

The first part of the algorithm consists of extracting the data from the database and proccesing it in order to properly compute the best path for each one of the trucks.

To avoid the time/space/proccesing cost of reproccesing past data each time this is executed, the calculations for each day will continue on the past calculations (except in case of dataloss). The results will be loaded to a nonrelational "cache" DB. This will ease the compute power needed by using the key principles of dynamic programming.

This part of the algorithm could be classified as a "job", executed periodically (i.e. when a new entry is added to the main relational DB), rather than part of the algorithm that computes the routes. Nevertheless, it is as important as the rest of the process.

Here is a possible pseudocode aproach to this part of the algorithm.

```java
// Get new data from the directional DB

hashmap data = {get id from DB, [get weight from DB, get density from DB]} // Add new data

// computeWeight/computeDensity can calculate an avg
double new_weight  = computeWeight(cacheDB.get(id from data).get(0))
double new_density = computeDensity(cacheDB.get(id from data).get(1))

load new values to cacheDB for entries in data
```

This first part would consist of 3 interfaces, all contained in one module.

1. First interface would obtain data from the main (relational) database
2. Second interface would obtain the data from the cache (nonrelational) database
3. Third interface would put the new computed values back to the cache database.

## Solution computing

Using the data generated by the job, a solution will be computed using a series of heuristic + graph algorithms. Here is the step by step proceess of how it will be generated.

### Graph pre-processing

Before obtaining the routes for each expedition, a graph should be created containing information about the roads, containers, distances... One key of this model is that it will be a directed graph. A first aproximation to it could be:

* **Nodes:** The containers of this model. They should store information like the expected weight, density, and exact location of it. (Side of the road where it is located can also be considered).

* **Vertices:** The roads will be the vertices of the modeled graph. The should include information such as the lenght of said road and the speed limit (to estimate the time it takes to transverse it).

One thing to note about this first aproximation is that the roads will not be the "real world" roads, more like a combination of the roads transversed between a set of two containers. This means that the speed will be the average of those roads, and the distance the sum of the distances of this individual roads.

It is to be considered that the first time the graph is created, the roads will be generated. After this, the roads do not need to be created again. In fact, nothing needs to be created per-se, but the nodes will need to be updated.

Other models could be considered for the roads, such as using the manhattan or vectorial distance between two containers.

```java
// Create a list of all the nodes
list nodes = empty list
for (entry in cacheDB) {
    nodes.add(entry.weight, entry.density, locationDB.location);
}

// Create a list of all the vertices
list vertices = empty list
for (road) {
    // Obtain here the theoretical road from the "real world" ones
    Road road = getRoad()
    vertices.add(road.lenght, road.speed)
}
```

This step will be contained in a new module, and will have an interface with the databases used to obtain the data.

### Graph creation

Once the previous step is completed and the nodes and vertices of the are obtained, the graph needs to be created. This would follow a simple creation of a directed-weighted graph. It is important to use a standard implementation, thus making the use of graph algorithms simpler. This could be achieved by creating the data types `Node` and `Vertex`, with the data they should contain.

As stated earlier, the graph will only be created from scratch the first time the algorithm is created. Later on, it will be updated using the newly obtained values for the nodes (and roads if, for example, speed limits change).

To isolate the diferent steps of the proccess, the creation will be in a separate module to the graph pre-processing. This will help segregate responsibilities inside the code.

### Route calculation & route sending

Once the graph is generated/updated, an heuristic-based algorithm will be used to get the route for each truck.

This algorithm could be a modification of a graph search algo, an A* algorithm, or an heuristic algorithm based on unsurpervised training of a starting algorithm.

It has to be taken into account that the algorithm should update the graph when a container is to be picked up by a truck, to avoid multiple trucks receiving the same container(s).

This data also has to be sent to each truck. To ensure a safe and stable communication, the truck should send a connection confirmation (or the algorithm should send dummy data and await confirmation), as well as await confirmation from the truck once the route is received by it.

A posible pseudocode for this module could be:

```java
//Load graph
graph model = getGraph()

for (truck in fleet) {
    Route route = calculateRoute() // This would be teh algorithm
    updateGraph() // To avoid more multiple trucks per container
    sendRouteToTruck(truck, route)
}

// Function sendRouteToTruck
sendRouteToTruck(truck, route) {
    connect(truck)
    sendData(route)
    while (route recieved not confirmed) waitConfirmation()
    if (too much time passed) sendData()
    closeConnection(truck)
}
```

This last module should load the graph, or use an interface with the graph update/creation module.

## Mock graph

## Interface glosary

Interface Name Description
I.1       a    abcde
...

## Notes

* More databases could (and probably should) be used, such as one containing the location of each container, or one with the lengths and speed limits of each road.
